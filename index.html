<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Mobile AprilTag Detector</title>
  <meta name="description" content="GitHub Pages å¯ç›´æ¥éƒ¨ç½²çš„æ‰‹æœºç«¯ AprilTag è¯†åˆ«ä¸è¿½è¸ªï¼ˆWASMï¼‰ã€‚" />
  <style>
    :root{--bg:#0b0f14;--fg:#e6eef7;--muted:#9fb3c8;--accent:#3da9fc;--warn:#f4bf4f;--ok:#2cb67d}
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji"}
    #app{display:grid;grid-template-rows:auto 1fr auto;min-height:100%}
    header{position:sticky;top:0;background:rgba(11,15,20,.85);backdrop-filter:blur(8px);z-index:20;border-bottom:1px solid #1b2430}
    header .row{display:flex;gap:.5rem;align-items:center;padding:.6rem .75rem;flex-wrap:wrap}
    header .row > *{margin:.1rem 0}
    .btn{appearance:none;border:1px solid #243242;border-radius:12px;padding:.55rem .8rem;background:#121924;color:var(--fg);font-weight:600}
    .btn[disabled]{opacity:.5}
    .btn.primary{border-color:#2b6cb0;background:#123457}
    .btn.warn{border-color:#665517;background:#3a2e11;color:#ffe8b0}
    input,select{background:#0e141d;color:var(--fg);border:1px solid #243242;border-radius:10px;padding:.5rem .6rem}
    label{font-size:.9rem;color:var(--muted)}
    .controls{display:flex;gap:.5rem;align-items:center;flex-wrap:wrap}
    .stat{font-variant-numeric:tabular-nums}
    main{position:relative;overflow:hidden}
    #video{width:100%;height:100%;object-fit:cover;display:block;background:#000}
    canvas#overlay{position:absolute;inset:0;display:block}
    #msgs{min-height:1.25rem;padding:.4rem .75rem;color:var(--muted);border-top:1px solid #1b2430}
    .tagchip{display:inline-flex;gap:.3rem;align-items:center;background:#0e1921;border:1px solid #1e2b38;border-radius:999px;padding:.2rem .5rem;margin:.15rem;font-size:.8rem}
    .chipbox{overflow-x:auto;white-space:nowrap;padding:.35rem .5rem;border-top:1px solid #1b2430}
    .badge{padding:.15rem .4rem;border-radius:.5rem;border:1px solid #2a384a;background:#0e1620;color:#a7bed4;font-size:.8rem}
  </style>
</head>
<body>
<div id="app">
  <header>
    <div class="row controls">
      <button id="startBtn" class="btn primary">â–¶ å¼€å§‹</button>
      <button id="stopBtn" class="btn" disabled>â¹ åœæ­¢</button>
      <button id="switchBtn" class="btn">ğŸ”„ åˆ‡æ¢å‰/åæ‘„</button>
      <label>é»˜è®¤Tagå°ºå¯¸(m)
        <input id="tagSize" type="number" step="0.001" min="0.01" value="0.05" style="width:7ch"/>
      </label>
      <label>FOV(Â°)
        <input id="fov" type="number" step="1" min="30" max="100" value="60" style="width:5ch"/>
      </label>
      <label>åˆ†è¾¨ç‡
        <select id="res">
          <option value="1280x720">1280Ã—720</option>
          <option value="1920x1080">1920Ã—1080</option>
          <option value="640x480">640Ã—480</option>
        </select>
      </label>
      <label><input id="showPose" type="checkbox" checked/> æ˜¾ç¤ºå§¿æ€è½´</label>
      <label><input id="showIds" type="checkbox" checked/> æ˜¾ç¤ºID</label>
      <span class="badge">tag36h11</span>
    </div>
  </header>
  <main>
    <video id="video" playsinline muted></video>
    <canvas id="overlay"></canvas>
  </main>
  <div class="chipbox" id="chips" aria-live="polite"></div>
  <div id="msgs" class="stat">å‡†å¤‡ä¸­â€¦ è¯·å…ˆç‚¹å‡»â€œå¼€å§‹â€ï¼Œå¹¶å…è®¸ä½¿ç”¨æ‘„åƒå¤´ã€‚</div>
</div>

<!--
  ä¾èµ–ï¼šå°† apriltag_wasm.js ä¸ apriltag_wasm.wasm æ”¾åœ¨ä¸æœ¬æ–‡ä»¶åŒç›®å½•ã€‚
  GitHub Pagesï¼ˆHTTPSï¼‰å¯ç›´æ¥éƒ¨ç½²ï¼šæ ¹ç›®å½•éœ€åŒ…å« index.htmlã€apriltag_wasm.jsã€apriltag_wasm.wasmã€‚
-->
<script>
  // ä¸€äº› WASM å‘è¡Œç‰ˆï¼ˆEmscriptenï¼‰ä¼šè¯»å– Module.locateFile() æ¥å¯»æ‰¾ .wasm è·¯å¾„ã€‚
  // è¿™é‡Œåšä¸€ä¸ªå…œåº•ï¼Œç¡®ä¿ .wasm ä¸æœ¬é¡µåŒç›®å½•æ—¶èƒ½è¢«æ­£ç¡®åŠ è½½ã€‚
  // å¦‚æœä½ çš„ apriltag_wasm.js ä½¿ç”¨å…¶å®ƒå‘½åï¼ˆä¾‹å¦‚ ApriltagModuleï¼‰ï¼Œå¯æŒ‰éœ€è¦æ”¹åã€‚
  window.Module = window.Module || {};
  Module.locateFile = Module.locateFile || function(path){
    // å°†è·¯å¾„æŒ‡å‘å½“å‰ç›®å½•
    const base = location.href.replace(/[#?].*$/,'').replace(/[^\/]*$/,'');
    return base + path;
  };
</script>
<script defer src="./apriltag_wasm.js"></script>
<script>
(function(){
  const els = {
    start: document.getElementById('startBtn'),
    stop: document.getElementById('stopBtn'),
    switch: document.getElementById('switchBtn'),
    video: document.getElementById('video'),
    overlay: document.getElementById('overlay'),
    tagSize: document.getElementById('tagSize'),
    fov: document.getElementById('fov'),
    res: document.getElementById('res'),
    showPose: document.getElementById('showPose'),
    showIds: document.getElementById('showIds'),
    msgs: document.getElementById('msgs'),
    chips: document.getElementById('chips'),
  };

  let detector = null; // Apriltag detector instance (from wasm)
  let stream = null;   // MediaStream
  let facing = 'environment';
  let running = false;
  let processing = false;
  const seenSizes = new Map(); // tagId -> size(m)
  const tracks = new Map();    // tagId -> {x,y,ts}
  const ema = (prev, next, a=0.25)=> prev==null? next : prev*(1-a)+next*a;

  // ä¸€äº› apriltag wasm å‘è¡Œç‰ˆä¼šåœ¨å…¨å±€æš´éœ² Apriltag() å·¥å‚ï¼›
  // å¦‚æœä½ çš„ç‰ˆæœ¬æ˜¯ createApriltagDetector() æˆ– new AprilTag(), å¯ä»¥åœ¨è¿™é‡Œæ”¹ä¸€ä¸‹åˆ›å»ºé€»è¾‘ã€‚
  function initApriltag(){
    return new Promise((resolve, reject)=>{
      try {
        if(typeof Apriltag === 'function'){
          detector = Apriltag(()=>{ // wasm ready callback
            try{
              if(detector.set_max_detections) detector.set_max_detections(0);
              if(detector.set_return_pose) detector.set_return_pose(1);
              if(detector.set_return_solutions) detector.set_return_solutions(0);
              logMsg('AprilTag å¼•æ“å·²åŠ è½½ã€‚');
              resolve();
            }catch(e){ reject(e); }
          });
        } else if(typeof createApriltagDetector === 'function'){
          createApriltagDetector().then(inst=>{ detector = inst; logMsg('AprilTag å¼•æ“å·²åŠ è½½ã€‚'); resolve(); }).catch(reject);
        } else {
          reject(new Error('æœªæ‰¾åˆ° Apriltag å·¥å‚å‡½æ•°ï¼ˆApriltag/createApriltagDetectorï¼‰ã€‚'));
        }
      } catch(e){ reject(e); }
    });
  }

  // Camera helpers
  async function openCamera(){
    const [w,h] = els.res.value.split('x').map(Number);
    const constraints = { video: { facingMode: { ideal: facing }, width: {ideal:w}, height:{ideal:h} }, audio:false };
    if(stream){ stream.getTracks().forEach(t=>t.stop()); }
    stream = await navigator.mediaDevices.getUserMedia(constraints);
    els.video.srcObject = stream;
    await els.video.play();
    sizeCanvasToVideo();
    applyCameraIntrinsics();
  }

  function sizeCanvasToVideo(){
    const rect = els.video.getBoundingClientRect();
    els.overlay.width = Math.max(1, Math.round(rect.width * devicePixelRatio));
    els.overlay.height = Math.max(1, Math.round(rect.height * devicePixelRatio));
  }

  function applyCameraIntrinsics(){
    const vw = els.video.videoWidth || 1280;
    const vh = els.video.videoHeight || 720;
    const fov = (+els.fov.value||60) * Math.PI/180;
    const fx = 0.5*vw/Math.tan(0.5*fov);
    const fy = fx; // è¿‘ä¼¼
    const cx = vw/2, cy = vh/2;
    if(detector && detector.set_camera_info) detector.set_camera_info(fx, fy, cx, cy);
  }

  function logMsg(t){ els.msgs.textContent = t; }

  function addChip(id){
    if(document.getElementById('chip-'+id)) return;
    const el = document.createElement('span');
    el.className = 'tagchip';
    el.id = 'chip-'+id;
    el.textContent = 'Tag '+id;
    els.chips.appendChild(el);
  }

  async function detectLoop(){
    if(!running) return;
    if(!detector || !stream) return;
    if(processing){ requestAnimationFrame(detectLoop); return; }
    processing = true;

    try{
      const vw = els.video.videoWidth, vh = els.video.videoHeight;
      if(vw===0||vh===0){ processing=false; requestAnimationFrame(detectLoop); return; }

      const off = detectLoop._off || (detectLoop._off = document.createElement('canvas'));
      if(off.width!==vw){ off.width=vw; off.height=vh; }
      const octx = off.getContext('2d', {willReadFrequently:true});
      octx.drawImage(els.video, 0,0, vw, vh);
      const {data} = octx.getImageData(0,0,vw,vh);

      // RGB -> grayscale Uint8
      let gray = detectLoop._gray;
      if(!gray || gray.length!==vw*vh) gray = detectLoop._gray = new Uint8Array(vw*vh);
      for(let i=0,j=0;i<data.length;i+=4,++j){ gray[j] = (data[i]*0.299 + data[i+1]*0.587 + data[i+2]*0.114)|0; }

      // Run detector (API: detect(gray,width,height))
      const detections = await detector.detect(gray, vw, vh);

      // Set tag size for pose (once per id)
      const defSize = parseFloat(els.tagSize.value)||0.05;
      if(detector.set_tag_size){
        for(const d of detections){ if(!seenSizes.has(d.id)){ detector.set_tag_size(d.id, defSize); seenSizes.set(d.id, defSize); } }
      }

      drawOverlay(detections);

      processing = false;
      requestAnimationFrame(detectLoop);
    }catch(err){
      processing=false; running=false;
      logMsg('æ£€æµ‹å‡ºé”™ï¼š'+err.message);
      console.error(err);
    }
  }

  function drawOverlay(detections){
    const ctx = els.overlay.getContext('2d');
    const scale = devicePixelRatio;
    const vw = els.video.getBoundingClientRect().width * scale;
    const vh = els.video.getBoundingClientRect().height * scale;
    if(els.overlay.width!==vw || els.overlay.height!==vh){ els.overlay.width = vw; els.overlay.height = vh; }

    ctx.clearRect(0,0,vw,vh);
    ctx.save();
    ctx.lineWidth = 3; ctx.font = `${14*scale}px system-ui`; ctx.textBaseline='top';

    const now = performance.now();
    for(const d of detections){
      addChip(d.id);
      const prev = tracks.get(d.id) || {x:null,y:null,ts:now};
      const cx = ema(prev.x, d.center.x*scale), cy = ema(prev.y, d.center.y*scale);
      tracks.set(d.id, {x:cx,y:cy,ts:now});

      const c = d.corners.map(k=>({x:k.x*scale,y:k.y*scale}));
      ctx.strokeStyle = 'rgba(61,169,252,0.95)';
      ctx.beginPath(); ctx.moveTo(c[0].x,c[0].y); for(let i=1;i<c.length;i++) ctx.lineTo(c[i].x,c[i].y); ctx.closePath(); ctx.stroke();

      ctx.fillStyle = 'rgba(44,182,125,0.95)';
      ctx.beginPath(); ctx.arc(cx,cy,6,0,Math.PI*2); ctx.fill();

      if(els.showIds.checked){ ctx.fillStyle = 'rgba(230,238,247,.95)'; ctx.fillText(`ID:${d.id}`, c[0].x+6, c[0].y+6); }

      if(els.showPose.checked && d.pose && d.pose.R && d.pose.t){
        const vwpx = els.video.videoWidth, vhpx = els.video.videoHeight;
        const fov = (+els.fov.value||60)*Math.PI/180; const fx = 0.5*vwpx/Math.tan(0.5*fov); const fy = fx; const cx0 = vwpx/2, cy0 = vhpx/2;
        const K = {fx,fy,cx:cx0,cy:cy0};
        const R = d.pose.R, t = d.pose.t; // R: 3x3, t: [x,y,z] (m)
        const axisLen = (seenSizes.get(d.id)||parseFloat(els.tagSize.value)||0.05) * 1.5; // meters
        const origin = project([0,0,0], R, t, K);
        const X = project([axisLen,0,0], R, t, K);
        const Y = project([0,axisLen,0], R, t, K);
        const Z = project([0,0,axisLen], R, t, K);
        const s = (p)=>({x:p.x*scale, y:p.y*scale});
        drawAxis(ctx, s(origin), s(X), s(Y), s(Z));
      }
    }

    for(const [id, tr] of tracks){ if(now - tr.ts > 800) tracks.delete(id); }

    ctx.restore();

    drawOverlay._last = drawOverlay._last || now;
    const dt = now - drawOverlay._last; drawOverlay._last = now;
    const fps = (1000/dt).toFixed(1);
    logMsg(`æ£€æµ‹æ•°: ${detections.length} | ~${fps} FPS | æ‘„åƒå¤´: ${facing}`);
  }

  function project(P, R, t, K){
    const Xc = [
      R[0][0]*P[0]+R[0][1]*P[1]+R[0][2]*P[2]+t[0],
      R[1][0]*P[0]+R[1][1]*P[1]+R[1][2]*P[2]+t[1],
      R[2][0]*P[0]+R[2][1]*P[1]+R[2][2]*P[2]+t[2]
    ];
    const x = (K.fx*Xc[0]/Xc[2]) + K.cx;
    const y = (K.fy*Xc[1]/Xc[2]) + K.cy;
    return {x,y};
  }

  function drawAxis(ctx, O, X, Y, Z){
    ctx.save(); ctx.lineWidth=4;
    ctx.strokeStyle='rgba(255,80,80,0.95)'; line(O,X);
    ctx.strokeStyle='rgba(80,255,80,0.95)'; line(O,Y);
    ctx.strokeStyle='rgba(80,160,255,0.95)'; line(O,Z);
    ctx.restore();
    function line(a,b){ ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke(); }
  }

  // Wire UI
  els.start.addEventListener('click', async ()=>{
    try{
      if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){ throw new Error('å½“å‰æµè§ˆå™¨ä¸æ”¯æŒæ‘„åƒå¤´ API'); }
      els.start.disabled = true;
      if(!detector) await initApriltag();
      await openCamera();
      running = true; els.stop.disabled=false; logMsg('æ‘„åƒå¤´å·²å¼€å¯ï¼Œå¼€å§‹æ£€æµ‹â€¦');
      requestAnimationFrame(detectLoop);
    }catch(err){ logMsg('æ— æ³•å¼€å¯ï¼š'+ err.message + 'ï¼ˆè¯·ç¡®è®¤ä½¿ç”¨ HTTPSï¼Œä¸”å·²æˆæƒç›¸æœºï¼‰'); els.start.disabled=false; }
  });
  els.stop.addEventListener('click', ()=>{ running=false; els.stop.disabled=true; if(stream){stream.getTracks().forEach(t=>t.stop());} logMsg('å·²åœæ­¢'); els.start.disabled=false; });
  els.switch.addEventListener('click', async ()=>{ facing = (facing==='environment'? 'user':'environment'); if(running){ await openCamera(); }});
  els.fov.addEventListener('change', ()=> applyCameraIntrinsics());
  els.res.addEventListener('change', async ()=>{ if(running) await openCamera(); });

  window.addEventListener('resize', sizeCanvasToVideo);
})();
</script>
</body>
</html>
